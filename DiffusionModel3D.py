import torch
from diffusers import ShapEPipeline
import numpy as np
import matplotlib.pyplot as plt

from TriangleMesh import TriangleMesh
from PointClouds import PointClouds

# Class representing the first stage of our GaussianDreamer implementation
class DiffusionModel3D():

    def __init__(self, prompt):
        # prompt for the 3d diffusion model
        self.prompt = prompt
        # resulting converted mesh
        self.mesh = TriangleMesh()
        # attributes of original mesh generated by 3d diffusion model
        self.vertices = None
        self.faces = None
        self.colors = None
        # resulting point_clouds
        self.point_clouds = PointClouds()

    def generateTriangleMesh(self):
        pipe = ShapEPipeline.from_pretrained("openai/shap-e").to("cuda")

        # pass the prompt to shape-e and generate a 3d mesh
        guidance_scale = 15.0
        mesh_list = pipe(
            self.prompt,
            guidance_scale=guidance_scale,
            num_inference_steps=64,
            frame_size=256,
            output_type="mesh"
        ).images
        # convert the mesh for easier point cloud conversion
        self.convertMesh(mesh_list[0])

        # free the model memory from cuda
        del pipe
        del mesh_list
        torch.cuda.empty_cache()

    # convert the mesh for easier point cloud conversion
    def convertMesh(self, mesh):
        self.vertices = mesh.verts.cpu()
        self.faces = mesh.faces.cpu()
        self.colors = self.getColors(mesh.vertex_channels)

        self.getTriangleMesh()
        torch.cuda.empty_cache()

    # Generate the efficient triangle mesh from the original
    def getTriangleMesh(self):
        for v1_ind, v2_ind, v3_ind in self.faces:
            self.mesh.vertices.append([self.vertices[v1_ind], self.vertices[v2_ind], self.vertices[v3_ind]])
            self.mesh.colors.append([self.colors[v1_ind], self.colors[v2_ind], self.colors[v3_ind]])

        self.mesh.vertices = np.array(self.mesh.vertices)
        self.mesh.colors = np.array(self.mesh.colors)

    # Extract the colors for each face
    def getColors(self, color_dict):
        colors = []
        for i in range(len(color_dict['R'])):
            color_arr = np.array([color_dict['R'].cpu()[i], color_dict['G'].cpu()[i], color_dict['B'].cpu()[i]])
            colors.append(color_arr)

        return torch.tensor(colors)

    # Generate point clouds with weighted random generation
    # The number of point clouds depends on sample_proportion
    def generatePointClouds(self, sample_proportion):
        triangle_areas = self.calcTriangleAreas(self.mesh.vertices[:, 0, :],
                                                self.mesh.vertices[:, 1, :],
                                                self.mesh.vertices[:, 2, :])

        randomly_weighted_vertices = np.random.choice(range(len(triangle_areas)),
                                                      size=int(len(triangle_areas) * sample_proportion),
                                                      p=triangle_areas / sum(triangle_areas))

        self.mesh.vertices = self.mesh.vertices[randomly_weighted_vertices]
        self.mesh.colors = self.mesh.colors[randomly_weighted_vertices]

        u = np.random.rand(int(len(triangle_areas) * sample_proportion), 1)
        v = np.random.rand(int(len(triangle_areas) * sample_proportion), 1)
        u[u + v > 1] = 1 - u[u + v > 1]
        v[u + v > 1] = 1 - v[u + v > 1]

        self.point_clouds.vertices = ((self.mesh.vertices[:, 0, :] * u)
                                      + (self.mesh.vertices[:, 1, :] * v)
                                      + ((1 - u - v) * self.mesh.vertices[:, 2, :])).astype(np.float32)
        self.point_clouds.colors = ((self.mesh.colors[:, 0, :] * u)
                                    + (self.mesh.colors[:, 1, :] * v)
                                    + ((1 - u - v) * self.mesh.colors[:, 2, :])).astype(np.float32)

    def calcTriangleAreas(self, v1_arr, v2_arr, v3_arr):
        return np.linalg.norm(np.cross(v2_arr - v1_arr, v3_arr - v1_arr), axis=1)

    def visualizePointClouds(self):
        figure = plt.figure(figsize=(6, 6))
        ax = figure.add_subplot(111, projection='3d')
        ax.set_xlim((-1, 1))
        ax.set_ylim((-1, 1))
        ax.set_zlim((-1, 1))
        ax.scatter(self.point_clouds.vertices[:, 0],
                   self.point_clouds.vertices[:, 1],
                   self.point_clouds.vertices[:, 2],
                   c=self.point_clouds.colors,
                   s=1)
        plt.savefig('PointClouds.png')

    def visualizePointCloudsViews(self):
        figure = plt.figure(figsize=(6, 9), tight_layout=True)

        # XY view
        ax1 = figure.add_subplot(231, projection='3d')
        self.configureSubplot(ax1, 90, -90, "XY View")

        # XZ view
        ax2 = figure.add_subplot(232, projection='3d')
        self.configureSubplot(ax2, 0, -90, "XZ View")

        # YZ view
        ax3 = figure.add_subplot(233, projection='3d')
        self.configureSubplot(ax3, 0, 0, "YZ View")

        # -XZ view
        ax4 = figure.add_subplot(234, projection='3d')
        self.configureSubplot(ax4, 0, 90, "-XZ View")

        # -YZ view
        ax5 = figure.add_subplot(235, projection='3d')
        self.configureSubplot(ax5, 0, 180, "-VZ view")

        # -XY view
        ax6 = figure.add_subplot(236, projection='3d')
        self.configureSubplot(ax6, -90, 90, "-XY view")

        figure.subplots_adjust(wspace=0.05, hspace=0.05)
        plt.savefig('PointCloudsViews.png')

    def configureSubplot(self, ax, elev, azim, title):
        ax.set_xlim((-1, 1))
        ax.set_ylim((-1, 1))
        ax.set_zlim((-1, 1))
        ax.view_init(elev, azim, 0)
        ax.set_title(title)
        ax.axis("off")
        ax.set_aspect("equal")
        ax.scatter(self.point_clouds.vertices[:, 0],
                   self.point_clouds.vertices[:, 1],
                   self.point_clouds.vertices[:, 2],
                   c=self.point_clouds.colors,
                   s=1)